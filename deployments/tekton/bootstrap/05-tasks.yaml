apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: reposentry-bootstrap-clone
  namespace: reposentry-system
  labels:
    reposentry.io/component: "bootstrap"
    reposentry.io/type: "task"
spec:
  description: "Clone user repository to analyze and extract Tekton resources"
  params:
  - name: repo-url
    type: string
    description: "Repository URL to clone"
  - name: repo-branch
    type: string
    description: "Repository branch to clone"
    default: "main"
  - name: commit-sha
    type: string
    description: "Specific commit SHA to checkout"
    default: ""
  workspaces:
  - name: source
    description: "Workspace to store cloned repository"
  steps:
  - name: clone-repository
    image: alpine/git:v2.40.1
    script: |
      set -e
      cd "$(workspaces.source.path)"
      
      echo "ðŸ”„ Cloning repository: $(params.repo-url)"
      echo "ðŸ“‚ Branch: $(params.repo-branch)"
      
      git clone "$(params.repo-url)" repo
      cd repo
      
      if [ -n "$(params.commit-sha)" ]; then
        echo "ðŸ“Œ Checking out commit: $(params.commit-sha)"
        git checkout "$(params.commit-sha)"
      else
        echo "ðŸ“Œ Using latest commit on branch: $(params.repo-branch)"
        git checkout "$(params.repo-branch)"
      fi
      
      echo "âœ… Repository cloned successfully"
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: reposentry-bootstrap-compute-namespace
  namespace: reposentry-system
  labels:
    reposentry.io/component: "bootstrap"
    reposentry.io/type: "task"
spec:
  description: "Compute target namespace for user resources"
  params:
  - name: repo-full-name
    type: string
    description: "Repository full name (org/repo)"
  - name: repo-url
    type: string
    description: "Repository URL"
  results:
  - name: namespace-name
    description: "Computed namespace name"
  steps:
  - name: compute-namespace
    image: alpine:3.18
    script: |
      set -e
      
      REPO_FULL_NAME="$(params.repo-full-name)"
      
      echo "ðŸ” Computing namespace for repository: $REPO_FULL_NAME"
      
      OWNER=$(echo "$REPO_FULL_NAME" | cut -d'/' -f1 | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
      REPO=$(echo "$REPO_FULL_NAME" | cut -d'/' -f2- | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
      
      NAMESPACE="reposentry-${OWNER}-${REPO}"
      
      if [ ${#NAMESPACE} -gt 63 ]; then
        NAMESPACE=$(echo "$NAMESPACE" | cut -c1-63 | sed 's/-$//')
      fi
      
      echo "âœ… Computed namespace: $NAMESPACE"
      echo -n "$NAMESPACE" > "$(results.namespace-name.path)"
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: reposentry-bootstrap-validate
  namespace: reposentry-system
  labels:
    reposentry.io/component: "bootstrap"
    reposentry.io/type: "task"
spec:
  description: "Validate Tekton resources and prepare for deployment"
  params:
  - name: tekton-path
    type: string
    description: "Path to Tekton resources in repository"
    default: ".tekton"
  - name: target-namespace
    type: string
    description: "Target namespace for validation"
  workspaces:
  - name: source
    description: "Workspace containing cloned repository"
  steps:
  - name: validate-tekton-resources
    image: bitnami/kubectl:1.28
    script: |
      set -e
      SOURCE_PATH="$(workspaces.source.path)/repo"
      TEKTON_PATH="$SOURCE_PATH/$(params.tekton-path)"
      TARGET_NS="$(params.target-namespace)"
      
      echo "ðŸ” Validating Tekton resources in: $TEKTON_PATH"
      
      if [ ! -d "$TEKTON_PATH" ]; then
        echo "âŒ Tekton resources directory not found: $TEKTON_PATH"
        exit 1
      fi
      
      mkdir -p "$(workspaces.source.path)/processed-tekton-resources"
      
      find "$TEKTON_PATH" -name "*.yaml" -o -name "*.yml" | while read file; do
        echo "âœ… Processing: $(basename "$file")"
        cp "$file" "$(workspaces.source.path)/processed-tekton-resources/"
      done
      
      echo "âœ… Tekton resources validated and prepared"
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: reposentry-bootstrap-ensure-namespace
  namespace: reposentry-system
  labels:
    reposentry.io/component: "bootstrap"
    reposentry.io/type: "task"
spec:
  description: "Ensure target namespace exists and is properly configured"
  params:
  - name: target-namespace
    type: string
    description: "Target namespace to create/ensure"
  - name: repo-url
    type: string
    description: "Repository URL for labeling"
  steps:
  - name: ensure-namespace
    image: bitnami/kubectl:1.28
    script: |
      set -e
      NAMESPACE="$(params.target-namespace)"
      REPO_URL="$(params.repo-url)"
      
      echo "ðŸ” Ensuring namespace exists: $NAMESPACE"
      
      if kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
        echo "âœ… Namespace $NAMESPACE already exists"
      else
        echo "ðŸ“ Creating namespace: $NAMESPACE"
        kubectl create namespace "$NAMESPACE"
      fi
      
      kubectl label namespace "$NAMESPACE" \
        reposentry.io/managed-by="bootstrap-pipeline" \
        reposentry.io/created-by="bootstrap-pipeline" \
        --overwrite
      
      kubectl annotate namespace "$NAMESPACE" \
        reposentry.io/repository-url="$REPO_URL" \
        --overwrite
      
      echo "Namespace $NAMESPACE is ready"
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: reposentry-bootstrap-apply
  namespace: reposentry-system
  labels:
    reposentry.io/component: "bootstrap"
    reposentry.io/type: "task"
spec:
  description: "Apply user Tekton Pipeline and Task definitions"
  params:
  - name: target-namespace
    type: string
    description: "Target namespace for resources"
  workspaces:
  - name: resources
    description: "Validated Tekton resources workspace"
  results:
  - name: pipeline-name
    description: "Name of the applied Pipeline"
  steps:
  - name: apply-resources
    image: bitnami/kubectl:1.28
    script: |
      set -e
      TARGET_NS="$(params.target-namespace)"
      RESOURCES_PATH="$(workspaces.resources.path)/processed-tekton-resources"
      
      echo "ðŸ“‹ Applying Tekton Pipeline and Task definitions to namespace $TARGET_NS"
      
      find "$RESOURCES_PATH" -name "*.yaml" -o -name "*.yml" | while read file; do
        if ! grep -q "kind: PipelineRun" "$file"; then
          echo "âœ… Applying $(basename "$file")"
          
          # Create temporary file and remove namespace conflicts
          TEMP_FILE="/tmp/$(basename "$file")"
          
          if grep -q "namespace:" "$file"; then
            echo "   ðŸ”§ Removing namespace fields (will use --namespace=$TARGET_NS)"
            sed '/namespace:/d' "$file" > "$TEMP_FILE"
          else
            echo "   ðŸ“ No namespace field found, copying as-is"
            cp "$file" "$TEMP_FILE"
          fi
          
          echo "   ðŸ“‹ Applying to namespace $TARGET_NS"
          kubectl apply -f "$TEMP_FILE" --namespace="$TARGET_NS"
          
          # Clean up temp file
          rm -f "$TEMP_FILE"
        else
          echo "â­ï¸  Skipping PipelineRun file: $(basename "$file")"
        fi
      done
      
      echo "âœ… Pipeline and Task resources applied successfully"
      
      PIPELINE_NAME=$(kubectl get pipelines -n "$TARGET_NS" -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
      
      if [ -n "$PIPELINE_NAME" ]; then
        echo "ðŸŽ¯ Found Pipeline: $PIPELINE_NAME"
        echo -n "$PIPELINE_NAME" > "$(results.pipeline-name.path)"
      else
        echo "âš ï¸  No Pipeline found in namespace $TARGET_NS"
        echo -n "" > "$(results.pipeline-name.path)"
      fi
---
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: reposentry-bootstrap-run
  namespace: reposentry-system
  labels:
    reposentry.io/component: "bootstrap"
    reposentry.io/type: "task"
spec:
  description: "Create and trigger user Pipeline execution"
  params:
  - name: target-namespace
    type: string
  - name: pipeline-name
    type: string
  - name: repo-url
    type: string
  - name: repo-branch
    type: string
  - name: commit-sha
    type: string
  - name: repo-full-name
    type: string
  steps:
  - name: create-pipelinerun
    image: bitnami/kubectl:1.28
    script: |
      #!/bin/bash
      set -e
      # Smart naming utility functions
      sanitize_name() {
        echo "$1" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//'
      }
      generate_user_pipeline_name() {
        local pipeline_name="$1"
        local repo_url="$2"
        local repo_fullname="$3"
        local repo_branch="$4"
        local commit_sha="$5"
        
        # Extract components
        local git_type=$(detect_git_type "$repo_url")  # 2 chars
        local repo_name=$(echo "$repo_fullname" | cut -d'/' -f2)  # Get repo name only (no owner)
        local branch=$(sanitize_name "$repo_branch")
        local commit5=$(echo "$commit_sha" | cut -c1-5)  # 5 chars (reduced from 7)
        
        # Optimized length allocation for 63 char limit
        # Format: pipeline-name-git-type-repo-name-branch-name-commit5
        # Fixed: git-type(2) + separators(4) + commit(5) = 11
        # Variable: 63 - 11 = 52 chars available
        # Allocation: pipeline(22) + repo(20) + branch(10) = 52
        
        pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 22)
        repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 20)
        branch=$(smart_truncate "$branch" 10)
        
        local name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        
        # Safety check - should rarely be needed with generous allocation
        if [ ${#name} -gt 63 ]; then
          echo "Warning: Name still too long after optimization: ${name}" >&2
          # Emergency fallback - reduce all components slightly
          pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 18)
          repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 16)
          branch=$(smart_truncate "$branch" 8)
          name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        fi
        
        echo "$name"
      }
      # Function to detect git type from URL and return abbreviation
      detect_git_type() {
        local repo_url="$1"
        
        # Convert to lowercase for matching
        local url_lower=$(echo "$repo_url" | tr '[:upper:]' '[:lower:]')
        
        # GitHub detection
        if echo "$url_lower" | grep -q "github\.com"; then
          echo "gh"
        # GitLab detection  
        elif echo "$url_lower" | grep -q "gitlab\.com\|gitlab\."; then
          echo "gl"
        # Bitbucket detection
        elif echo "$url_lower" | grep -q "bitbucket\.org\|bitbucket\."; then
          echo "bb"
        # Azure DevOps detection
        elif echo "$url_lower" | grep -q "dev\.azure\.com\|visualstudio\.com"; then
          echo "az"
        # Gitea detection
        elif echo "$url_lower" | grep -q "gitea\."; then
          echo "gt"
        # Forgejo detection
        elif echo "$url_lower" | grep -q "forgejo\."; then
          echo "fj"
        # SourceForge detection
        elif echo "$url_lower" | grep -q "sourceforge\.net"; then
          echo "sf"
        # Codeberg detection
        elif echo "$url_lower" | grep -q "codeberg\.org"; then
          echo "cb"
        # Self-hosted or unknown
        else
          echo "sh"
        fi
      }
      generate_user_pipeline_name() {
        local pipeline_name="$1"
        local repo_url="$2"
        local repo_fullname="$3"
        local repo_branch="$4"
        local commit_sha="$5"
        
        # Extract components
        local git_type=$(detect_git_type "$repo_url")  # 2 chars
        local repo_name=$(echo "$repo_fullname" | cut -d'/' -f2)  # Get repo name only (no owner)
        local branch=$(sanitize_name "$repo_branch")
        local commit5=$(echo "$commit_sha" | cut -c1-5)  # 5 chars (reduced from 7)
        
        # Optimized length allocation for 63 char limit
        # Format: pipeline-name-git-type-repo-name-branch-name-commit5
        # Fixed: git-type(2) + separators(4) + commit(5) = 11
        # Variable: 63 - 11 = 52 chars available
        # Allocation: pipeline(22) + repo(20) + branch(10) = 52
        
        pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 22)
        repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 20)
        branch=$(smart_truncate "$branch" 10)
        
        local name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        
        # Safety check - should rarely be needed with generous allocation
        if [ ${#name} -gt 63 ]; then
          echo "Warning: Name still too long after optimization: ${name}" >&2
          # Emergency fallback - reduce all components slightly
          pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 18)
          repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 16)
          branch=$(smart_truncate "$branch" 8)
          name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        fi
        
        echo "$name"
      }
      # Function to detect git type from URL and return abbreviation
      detect_git_type() {
        local repo_url="$1"
        
        # Convert to lowercase for matching
        local url_lower=$(echo "$repo_url" | tr '[:upper:]' '[:lower:]')
        
        # GitHub detection
        if echo "$url_lower" | grep -q "github\.com"; then
          echo "gh"
        # GitLab detection  
        elif echo "$url_lower" | grep -q "gitlab\.com\|gitlab\."; then
          echo "gl"
        # Bitbucket detection
        elif echo "$url_lower" | grep -q "bitbucket\.org\|bitbucket\."; then
          echo "bb"
        # Azure DevOps detection
        elif echo "$url_lower" | grep -q "dev\.azure\.com\|visualstudio\.com"; then
          echo "az"
        # Gitea detection
        elif echo "$url_lower" | grep -q "gitea\."; then
          echo "gt"
        # Forgejo detection
        elif echo "$url_lower" | grep -q "forgejo\."; then
          echo "fj"
        # SourceForge detection
        elif echo "$url_lower" | grep -q "sourceforge\.net"; then
          echo "sf"
        # Codeberg detection
        elif echo "$url_lower" | grep -q "codeberg\.org"; then
          echo "cb"
        # Self-hosted or unknown
        else
          echo "sh"
        fi
      }
      generate_user_pipeline_name() {
        local pipeline_name="$1"
        local repo_url="$2"
        local repo_fullname="$3"
        local repo_branch="$4"
        local commit_sha="$5"
        
        # Extract components
        local git_type=$(detect_git_type "$repo_url")  # 2 chars
        local repo_name=$(echo "$repo_fullname" | cut -d'/' -f2)  # Get repo name only (no owner)
        local branch=$(sanitize_name "$repo_branch")
        local commit5=$(echo "$commit_sha" | cut -c1-5)  # 5 chars (reduced from 7)
        
        # Optimized length allocation for 63 char limit
        # Format: pipeline-name-git-type-repo-name-branch-name-commit5
        # Fixed: git-type(2) + separators(4) + commit(5) = 11
        # Variable: 63 - 11 = 52 chars available
        # Allocation: pipeline(22) + repo(20) + branch(10) = 52
        
        pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 22)
        repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 20)
        branch=$(smart_truncate "$branch" 10)
        
        local name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        
        # Safety check - should rarely be needed with generous allocation
        if [ ${#name} -gt 63 ]; then
          echo "Warning: Name still too long after optimization: ${name}" >&2
          # Emergency fallback - reduce all components slightly
          pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 18)
          repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 16)
          branch=$(smart_truncate "$branch" 8)
          name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        fi
        
        echo "$name"
      }

      smart_truncate() {
        local str="$1"
        local max_len="$2"
        if [ ${#str} -le $max_len ]; then
          echo "$str"
        else
          echo "$str" | cut -c1-$max_len | sed 's/-$//'
        fi
      }
      generate_user_pipeline_name() {
        local pipeline_name="$1"
        local repo_url="$2"
        local repo_fullname="$3"
        local repo_branch="$4"
        local commit_sha="$5"
        
        # Extract components
        local git_type=$(detect_git_type "$repo_url")  # 2 chars
        local repo_name=$(echo "$repo_fullname" | cut -d'/' -f2)  # Get repo name only (no owner)
        local branch=$(sanitize_name "$repo_branch")
        local commit5=$(echo "$commit_sha" | cut -c1-5)  # 5 chars (reduced from 7)
        
        # Optimized length allocation for 63 char limit
        # Format: pipeline-name-git-type-repo-name-branch-name-commit5
        # Fixed: git-type(2) + separators(4) + commit(5) = 11
        # Variable: 63 - 11 = 52 chars available
        # Allocation: pipeline(22) + repo(20) + branch(10) = 52
        
        pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 22)
        repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 20)
        branch=$(smart_truncate "$branch" 10)
        
        local name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        
        # Safety check - should rarely be needed with generous allocation
        if [ ${#name} -gt 63 ]; then
          echo "Warning: Name still too long after optimization: ${name}" >&2
          # Emergency fallback - reduce all components slightly
          pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 18)
          repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 16)
          branch=$(smart_truncate "$branch" 8)
          name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        fi
        
        echo "$name"
      }
      # Function to detect git type from URL and return abbreviation
      detect_git_type() {
        local repo_url="$1"
        
        # Convert to lowercase for matching
        local url_lower=$(echo "$repo_url" | tr '[:upper:]' '[:lower:]')
        
        # GitHub detection
        if echo "$url_lower" | grep -q "github\.com"; then
          echo "gh"
        # GitLab detection  
        elif echo "$url_lower" | grep -q "gitlab\.com\|gitlab\."; then
          echo "gl"
        # Bitbucket detection
        elif echo "$url_lower" | grep -q "bitbucket\.org\|bitbucket\."; then
          echo "bb"
        # Azure DevOps detection
        elif echo "$url_lower" | grep -q "dev\.azure\.com\|visualstudio\.com"; then
          echo "az"
        # Gitea detection
        elif echo "$url_lower" | grep -q "gitea\."; then
          echo "gt"
        # Forgejo detection
        elif echo "$url_lower" | grep -q "forgejo\."; then
          echo "fj"
        # SourceForge detection
        elif echo "$url_lower" | grep -q "sourceforge\.net"; then
          echo "sf"
        # Codeberg detection
        elif echo "$url_lower" | grep -q "codeberg\.org"; then
          echo "cb"
        # Self-hosted or unknown
        else
          echo "sh"
        fi
      }
      generate_user_pipeline_name() {
        local pipeline_name="$1"
        local repo_url="$2"
        local repo_fullname="$3"
        local repo_branch="$4"
        local commit_sha="$5"
        
        # Extract components
        local git_type=$(detect_git_type "$repo_url")  # 2 chars
        local repo_name=$(echo "$repo_fullname" | cut -d'/' -f2)  # Get repo name only (no owner)
        local branch=$(sanitize_name "$repo_branch")
        local commit5=$(echo "$commit_sha" | cut -c1-5)  # 5 chars (reduced from 7)
        
        # Optimized length allocation for 63 char limit
        # Format: pipeline-name-git-type-repo-name-branch-name-commit5
        # Fixed: git-type(2) + separators(4) + commit(5) = 11
        # Variable: 63 - 11 = 52 chars available
        # Allocation: pipeline(22) + repo(20) + branch(10) = 52
        
        pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 22)
        repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 20)
        branch=$(smart_truncate "$branch" 10)
        
        local name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        
        # Safety check - should rarely be needed with generous allocation
        if [ ${#name} -gt 63 ]; then
          echo "Warning: Name still too long after optimization: ${name}" >&2
          # Emergency fallback - reduce all components slightly
          pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 18)
          repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 16)
          branch=$(smart_truncate "$branch" 8)
          name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        fi
        
        echo "$name"
      }
      # Function to detect git type from URL and return abbreviation
      detect_git_type() {
        local repo_url="$1"
        
        # Convert to lowercase for matching
        local url_lower=$(echo "$repo_url" | tr '[:upper:]' '[:lower:]')
        
        # GitHub detection
        if echo "$url_lower" | grep -q "github\.com"; then
          echo "gh"
        # GitLab detection  
        elif echo "$url_lower" | grep -q "gitlab\.com\|gitlab\."; then
          echo "gl"
        # Bitbucket detection
        elif echo "$url_lower" | grep -q "bitbucket\.org\|bitbucket\."; then
          echo "bb"
        # Azure DevOps detection
        elif echo "$url_lower" | grep -q "dev\.azure\.com\|visualstudio\.com"; then
          echo "az"
        # Gitea detection
        elif echo "$url_lower" | grep -q "gitea\."; then
          echo "gt"
        # Forgejo detection
        elif echo "$url_lower" | grep -q "forgejo\."; then
          echo "fj"
        # SourceForge detection
        elif echo "$url_lower" | grep -q "sourceforge\.net"; then
          echo "sf"
        # Codeberg detection
        elif echo "$url_lower" | grep -q "codeberg\.org"; then
          echo "cb"
        # Self-hosted or unknown
        else
          echo "sh"
        fi
      }
      generate_user_pipeline_name() {
        local pipeline_name="$1"
        local repo_url="$2"
        local repo_fullname="$3"
        local repo_branch="$4"
        local commit_sha="$5"
        
        # Extract components
        local git_type=$(detect_git_type "$repo_url")  # 2 chars
        local repo_name=$(echo "$repo_fullname" | cut -d'/' -f2)  # Get repo name only (no owner)
        local branch=$(sanitize_name "$repo_branch")
        local commit5=$(echo "$commit_sha" | cut -c1-5)  # 5 chars (reduced from 7)
        
        # Optimized length allocation for 63 char limit
        # Format: pipeline-name-git-type-repo-name-branch-name-commit5
        # Fixed: git-type(2) + separators(4) + commit(5) = 11
        # Variable: 63 - 11 = 52 chars available
        # Allocation: pipeline(22) + repo(20) + branch(10) = 52
        
        pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 22)
        repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 20)
        branch=$(smart_truncate "$branch" 10)
        
        local name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        
        # Safety check - should rarely be needed with generous allocation
        if [ ${#name} -gt 63 ]; then
          echo "Warning: Name still too long after optimization: ${name}" >&2
          # Emergency fallback - reduce all components slightly
          pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 18)
          repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 16)
          branch=$(smart_truncate "$branch" 8)
          name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        fi
        
        echo "$name"
      }

      parse_repo_fullname() {
        local fullname="$1"
        echo "$fullname" | tr '/' '-' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g'
      }
      generate_user_pipeline_name() {
        local pipeline_name="$1"
        local repo_url="$2"
        local repo_fullname="$3"
        local repo_branch="$4"
        local commit_sha="$5"
        
        # Extract components
        local git_type=$(detect_git_type "$repo_url")  # 2 chars
        local repo_name=$(echo "$repo_fullname" | cut -d'/' -f2)  # Get repo name only (no owner)
        local branch=$(sanitize_name "$repo_branch")
        local commit5=$(echo "$commit_sha" | cut -c1-5)  # 5 chars (reduced from 7)
        
        # Optimized length allocation for 63 char limit
        # Format: pipeline-name-git-type-repo-name-branch-name-commit5
        # Fixed: git-type(2) + separators(4) + commit(5) = 11
        # Variable: 63 - 11 = 52 chars available
        # Allocation: pipeline(22) + repo(20) + branch(10) = 52
        
        pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 22)
        repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 20)
        branch=$(smart_truncate "$branch" 10)
        
        local name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        
        # Safety check - should rarely be needed with generous allocation
        if [ ${#name} -gt 63 ]; then
          echo "Warning: Name still too long after optimization: ${name}" >&2
          # Emergency fallback - reduce all components slightly
          pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 18)
          repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 16)
          branch=$(smart_truncate "$branch" 8)
          name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        fi
        
        echo "$name"
      }
      # Function to detect git type from URL and return abbreviation
      detect_git_type() {
        local repo_url="$1"
        
        # Convert to lowercase for matching
        local url_lower=$(echo "$repo_url" | tr '[:upper:]' '[:lower:]')
        
        # GitHub detection
        if echo "$url_lower" | grep -q "github\.com"; then
          echo "gh"
        # GitLab detection  
        elif echo "$url_lower" | grep -q "gitlab\.com\|gitlab\."; then
          echo "gl"
        # Bitbucket detection
        elif echo "$url_lower" | grep -q "bitbucket\.org\|bitbucket\."; then
          echo "bb"
        # Azure DevOps detection
        elif echo "$url_lower" | grep -q "dev\.azure\.com\|visualstudio\.com"; then
          echo "az"
        # Gitea detection
        elif echo "$url_lower" | grep -q "gitea\."; then
          echo "gt"
        # Forgejo detection
        elif echo "$url_lower" | grep -q "forgejo\."; then
          echo "fj"
        # SourceForge detection
        elif echo "$url_lower" | grep -q "sourceforge\.net"; then
          echo "sf"
        # Codeberg detection
        elif echo "$url_lower" | grep -q "codeberg\.org"; then
          echo "cb"
        # Self-hosted or unknown
        else
          echo "sh"
        fi
      }
      generate_user_pipeline_name() {
        local pipeline_name="$1"
        local repo_url="$2"
        local repo_fullname="$3"
        local repo_branch="$4"
        local commit_sha="$5"
        
        # Extract components
        local git_type=$(detect_git_type "$repo_url")  # 2 chars
        local repo_name=$(echo "$repo_fullname" | cut -d'/' -f2)  # Get repo name only (no owner)
        local branch=$(sanitize_name "$repo_branch")
        local commit5=$(echo "$commit_sha" | cut -c1-5)  # 5 chars (reduced from 7)
        
        # Optimized length allocation for 63 char limit
        # Format: pipeline-name-git-type-repo-name-branch-name-commit5
        # Fixed: git-type(2) + separators(4) + commit(5) = 11
        # Variable: 63 - 11 = 52 chars available
        # Allocation: pipeline(22) + repo(20) + branch(10) = 52
        
        pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 22)
        repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 20)
        branch=$(smart_truncate "$branch" 10)
        
        local name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        
        # Safety check - should rarely be needed with generous allocation
        if [ ${#name} -gt 63 ]; then
          echo "Warning: Name still too long after optimization: ${name}" >&2
          # Emergency fallback - reduce all components slightly
          pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 18)
          repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 16)
          branch=$(smart_truncate "$branch" 8)
          name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        fi
        
        echo "$name"
      }
      # Function to detect git type from URL and return abbreviation
      detect_git_type() {
        local repo_url="$1"
        
        # Convert to lowercase for matching
        local url_lower=$(echo "$repo_url" | tr '[:upper:]' '[:lower:]')
        
        # GitHub detection
        if echo "$url_lower" | grep -q "github\.com"; then
          echo "gh"
        # GitLab detection  
        elif echo "$url_lower" | grep -q "gitlab\.com\|gitlab\."; then
          echo "gl"
        # Bitbucket detection
        elif echo "$url_lower" | grep -q "bitbucket\.org\|bitbucket\."; then
          echo "bb"
        # Azure DevOps detection
        elif echo "$url_lower" | grep -q "dev\.azure\.com\|visualstudio\.com"; then
          echo "az"
        # Gitea detection
        elif echo "$url_lower" | grep -q "gitea\."; then
          echo "gt"
        # Forgejo detection
        elif echo "$url_lower" | grep -q "forgejo\."; then
          echo "fj"
        # SourceForge detection
        elif echo "$url_lower" | grep -q "sourceforge\.net"; then
          echo "sf"
        # Codeberg detection
        elif echo "$url_lower" | grep -q "codeberg\.org"; then
          echo "cb"
        # Self-hosted or unknown
        else
          echo "sh"
        fi
      }
      generate_user_pipeline_name() {
        local pipeline_name="$1"
        local repo_url="$2"
        local repo_fullname="$3"
        local repo_branch="$4"
        local commit_sha="$5"
        
        # Extract components
        local git_type=$(detect_git_type "$repo_url")  # 2 chars
        local repo_name=$(echo "$repo_fullname" | cut -d'/' -f2)  # Get repo name only (no owner)
        local branch=$(sanitize_name "$repo_branch")
        local commit5=$(echo "$commit_sha" | cut -c1-5)  # 5 chars (reduced from 7)
        
        # Optimized length allocation for 63 char limit
        # Format: pipeline-name-git-type-repo-name-branch-name-commit5
        # Fixed: git-type(2) + separators(4) + commit(5) = 11
        # Variable: 63 - 11 = 52 chars available
        # Allocation: pipeline(22) + repo(20) + branch(10) = 52
        
        pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 22)
        repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 20)
        branch=$(smart_truncate "$branch" 10)
        
        local name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        
        # Safety check - should rarely be needed with generous allocation
        if [ ${#name} -gt 63 ]; then
          echo "Warning: Name still too long after optimization: ${name}" >&2
          # Emergency fallback - reduce all components slightly
          pipeline_name=$(smart_truncate "$(sanitize_name "$pipeline_name")" 18)
          repo_name=$(smart_truncate "$(sanitize_name "$repo_name")" 16)
          branch=$(smart_truncate "$branch" 8)
          name="${pipeline_name}-${git_type}-${repo_name}-${branch}-${commit5}"
        fi
        
        echo "$name"
      }

      
      NAMESPACE="$(params.target-namespace)"
      PIPELINE="$(params.pipeline-name)"
      REPO_URL="$(params.repo-url)"
      REPO_FULL_NAME="$(params.repo-full-name)"
      REPO_BRANCH="$(params.repo-branch)"
      COMMIT_SHA="$(params.commit-sha)"
      SHORT_SHA=$(echo "$COMMIT_SHA" | cut -c1-7)
      
      PIPELINERUN_NAME=$(generate_user_pipeline_name "$PIPELINE" "$REPO_URL" "$REPO_FULL_NAME" "$REPO_BRANCH" "$COMMIT_SHA")
      
      echo "ðŸš€ Creating PipelineRun: $PIPELINERUN_NAME"
      
      kubectl create -f - <<EOF
      apiVersion: tekton.dev/v1
      kind: PipelineRun
      metadata:
        name: $PIPELINERUN_NAME
        namespace: $NAMESPACE
        labels:
          reposentry.io/triggered-by: "bootstrap-pipeline"
          tekton.dev/pipeline: "$PIPELINE"
      spec:
        pipelineRef:
          name: $PIPELINE
        params:
        - name: git-url
          value: "$REPO_URL"
        - name: git-revision
          value: "$COMMIT_SHA"
        - name: git-short-sha
          value: "$SHORT_SHA"
        workspaces:
        - name: shared-data
          volumeClaimTemplate:
            spec:
              accessModes:
              - ReadWriteOnce
              resources:
                requests:
                  storage: 5Gi
      EOF
      
      echo "âœ… PipelineRun created: $PIPELINERUN_NAME"
