# RepoSentry Tekton ÈõÜÊàêÁî®Êà∑ÊåáÂçó

## üéØ Ê¶ÇËø∞

RepoSentry ÁöÑ Tekton ÈõÜÊàêÂäüËÉΩÂÖÅËÆ∏ÊÇ®Âú®Ëá™Â∑±ÁöÑ‰ª£Á†Å‰ªìÂ∫ì‰∏≠ÂÆö‰πâ Tekton ÊµÅÊ∞¥Á∫øÔºåÂΩì‰ª£Á†ÅÂèëÁîüÂèòÊõ¥Êó∂ÔºåËøô‰∫õÊµÅÊ∞¥Á∫ø‰ºöËá™Âä®ÊâßË°å„ÄÇËøô‰∏™ËøáÁ®ãÂØπÊÇ®Êù•ËØ¥ÊòØÂÆåÂÖ®ÈÄèÊòéÁöÑ - ÊÇ®Âè™ÈúÄË¶ÅÂú®‰ªìÂ∫ì‰∏≠Ê∑ªÂä† `.tekton/` ÁõÆÂΩïÂíåÁõ∏ÂÖ≥ÁöÑ YAML Êñá‰ª∂Âç≥ÂèØ„ÄÇ

### üîß ÂΩìÂâçÂèØÁî®ÂäüËÉΩ
- ‚úÖ **Ëá™Âä®Ê£ÄÊµã**ÔºöÁõëÊéßÊÇ®‰ªìÂ∫ì‰∏≠ÁöÑ `.tekton/` ÁõÆÂΩïÂèòÂåñ
- ‚úÖ **ÈÄèÊòéÊâßË°å**Ôºö‰ª£Á†ÅÊèê‰∫§ÂêéËá™Âä®ÊâßË°åÊÇ®ÁöÑ Tekton ÊµÅÊ∞¥Á∫ø
- ‚úÖ **ÈÖçÁΩÆÂåñË∑ØÂæÑ**ÔºöÁÆ°ÁêÜÂëòÂèØÈÖçÁΩÆÂíåÊéßÂà∂Ê£ÄÊµãË∑ØÂæÑ
- ‚úÖ **Êô∫ËÉΩÂèëÁé∞**ÔºöËá™Âä®ÂèëÁé∞ÊÇ®‰ªìÂ∫ì‰∏≠ÁöÑ Tekton ËµÑÊ∫êÂπ∂Êèê‰æõÂª∫ËÆÆ
- ‚úÖ **ÂÆâÂÖ®ÈöîÁ¶ª**Ôºö‰∏∫ÊÇ®ÁöÑ‰ªìÂ∫ìÊèê‰æõÁã¨Á´ãÁöÑÊâßË°åÁéØÂ¢É

### üìã ÈïøËøúËÆ°ÂàíÂäüËÉΩ
- üìã **‰ºÅ‰∏öÊ≤ªÁêÜ**ÔºöÂàÜÂ±ÇÈÖçÁΩÆÁÆ°ÁêÜÂíåÁ≠ñÁï•Ê≤ªÁêÜÔºàÊöÇÊó∂‰∏çÂèØÁî®Ôºâ

## üöÄ Âø´ÈÄüÂºÄÂßã

### Á¨¨‰∏ÄÊ≠•ÔºöÂú®ÊÇ®ÁöÑ‰ªìÂ∫ì‰∏≠ÂàõÂª∫ Tekton ËµÑÊ∫ê

Âú®ÊÇ®ÁöÑ‰ª£Á†Å‰ªìÂ∫ìÊ†πÁõÆÂΩï‰∏ãÂàõÂª∫ `.tekton/` ÁõÆÂΩïÔºö

```bash
mkdir .tekton
cd .tekton
```

### Á¨¨‰∫åÊ≠•ÔºöÂàõÂª∫ÊÇ®ÁöÑÁ¨¨‰∏Ä‰∏™ Pipeline

ÂàõÂª∫‰∏Ä‰∏™ÁÆÄÂçïÁöÑÊûÑÂª∫ÂíåÊµãËØïÊµÅÊ∞¥Á∫øÔºö

```yaml
# .tekton/pipeline.yaml
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: my-app-ci
  labels:
    app: my-app
spec:
  params:
    - name: repository-url
      type: string
      description: "Git repository URL"
    - name: commit-sha
      type: string
      description: "Git commit SHA"
    - name: repository-name
      type: string
      description: "Repository name"
  
  workspaces:
    - name: source-code
    - name: docker-credentials
      optional: true
  
  tasks:
    - name: git-clone
      taskRef:
        name: git-clone
        kind: ClusterTask
      params:
        - name: url
          value: $(params.repository-url)
        - name: revision
          value: $(params.commit-sha)
      workspaces:
        - name: output
          workspace: source-code
    
    - name: run-tests
      runAfter: ["git-clone"]
      taskSpec:
        workspaces:
          - name: source
        steps:
          - name: test
            image: node:16
            workingDir: $(workspaces.source.path)
            script: |
              #!/bin/bash
              echo "üß™ Running tests for $(params.repository-name)..."
              
              # Ê£ÄÊü•ÊòØÂê¶Â≠òÂú® package.json
              if [ -f "package.json" ]; then
                npm install
                npm test
              fi
              
              # Ê£ÄÊü•ÊòØÂê¶Â≠òÂú® go.mod
              if [ -f "go.mod" ]; then
                go test ./...
              fi
              
              # Ê£ÄÊü•ÊòØÂê¶Â≠òÂú® pom.xml
              if [ -f "pom.xml" ]; then
                mvn test
              fi
              
              echo "‚úÖ Tests completed!"
      workspaces:
        - name: source
          workspace: source-code
    
    - name: build-image
      runAfter: ["run-tests"]
      taskSpec:
        workspaces:
          - name: source
          - name: dockerconfig
            optional: true
        params:
          - name: image-name
            default: "$(params.repository-name):$(params.commit-sha)"
        steps:
          - name: build
            image: gcr.io/kaniko-project/executor:latest
            workingDir: $(workspaces.source.path)
            script: |
              #!/busybox/sh
              echo "üî® Building container image..."
              
              # Ê£ÄÊü•ÊòØÂê¶Â≠òÂú® Dockerfile
              if [ -f "Dockerfile" ]; then
                echo "Found Dockerfile, building image: $(params.image-name)"
                /kaniko/executor \
                  --context $(workspaces.source.path) \
                  --dockerfile $(workspaces.source.path)/Dockerfile \
                  --destination $(params.image-name) \
                  --no-push
              else
                echo "‚ö†Ô∏è  No Dockerfile found, skipping image build"
              fi
            env:
              - name: DOCKER_CONFIG
                value: $(workspaces.dockerconfig.path)
      workspaces:
        - name: source
          workspace: source-code
        - name: dockerconfig
          workspace: docker-credentials
```

### Á¨¨‰∏âÊ≠•ÔºöÊèê‰∫§‰ª£Á†Å

Â∞ÜÊÇ®ÁöÑ `.tekton/` ÁõÆÂΩïÊèê‰∫§Âà∞ Git ‰ªìÂ∫ìÔºö

```bash
git add .tekton/
git commit -m "Add Tekton CI pipeline"
git push origin main
```

### Á¨¨ÂõõÊ≠•ÔºöËßÇÂØüÊâßË°åÁªìÊûú

Êèê‰∫§‰ª£Á†ÅÂêéÔºåRepoSentry ‰ºöËá™Âä®Ê£ÄÊµãÂà∞ÊÇ®ÁöÑ Tekton ËµÑÊ∫êÂπ∂ÊâßË°å Pipeline„ÄÇÊÇ®ÂèØ‰ª•ÈÄöËøá‰ª•‰∏ãÊñπÂºèÊü•ÁúãÊâßË°åÁä∂ÊÄÅÔºö

```bash
# Êü•ÁúãÊÇ®ÁöÑÂëΩÂêçÁ©∫Èó¥‰∏≠ÁöÑ PipelineRun (‰ΩøÁî®ÂìàÂ∏åÂëΩÂêçÁ©∫Èó¥)
kubectl get pipelineruns -n reposentry-user-{namespace-hash}

# Êü•Áúã Pipeline ÊâßË°åÊó•Âøó
kubectl logs -f pipelinerun/{pipelinerun-name} -n reposentry-user-{namespace-hash}

# Ê≥®ÊÑèÔºönamespace-hash ÊòØÊ†πÊçÆÊÇ®ÁöÑ‰ªìÂ∫ì‰ø°ÊÅØÁîüÊàêÁöÑÂìàÂ∏åÂÄº
# ÂèØ‰ª•ÈÄöËøá‰ª•‰∏ãÂëΩ‰ª§Êü•ËØ¢ÊÇ®ÁöÑÂëΩÂêçÁ©∫Èó¥Ôºö
kubectl get namespaces -l reposentry.dev/repository={your-repo}
```

## üìÅ ÁõÆÂΩïÁªìÊûÑÂª∫ËÆÆ

Êé®ËçêÁöÑ `.tekton/` ÁõÆÂΩïÁªìÊûÑÔºö

```
.tekton/
‚îú‚îÄ‚îÄ pipeline.yaml              # ‰∏ªÊµÅÊ∞¥Á∫øÂÆö‰πâ
‚îú‚îÄ‚îÄ tasks/                     # Ëá™ÂÆö‰πâ‰ªªÂä°
‚îÇ   ‚îú‚îÄ‚îÄ build-task.yaml
‚îÇ   ‚îú‚îÄ‚îÄ test-task.yaml
‚îÇ   ‚îî‚îÄ‚îÄ deploy-task.yaml
‚îú‚îÄ‚îÄ pipelines/                 # Â§ö‰∏™ÊµÅÊ∞¥Á∫ø
‚îÇ   ‚îú‚îÄ‚îÄ ci-pipeline.yaml
‚îÇ   ‚îú‚îÄ‚îÄ cd-pipeline.yaml
‚îÇ   ‚îî‚îÄ‚îÄ release-pipeline.yaml
‚îú‚îÄ‚îÄ triggers/                  # Ëß¶ÂèëÂô®ÈÖçÁΩÆÔºàÂèØÈÄâÔºâ
‚îÇ   ‚îú‚îÄ‚îÄ binding.yaml
‚îÇ   ‚îî‚îÄ‚îÄ template.yaml
‚îú‚îÄ‚îÄ configs/                   # ÈÖçÁΩÆÊñá‰ª∂
‚îÇ   ‚îú‚îÄ‚îÄ workspace-template.yaml
‚îÇ   ‚îî‚îÄ‚îÄ secrets-template.yaml
‚îî‚îÄ‚îÄ environments/              # ÁéØÂ¢ÉÁâπÂÆöÈÖçÁΩÆ
    ‚îú‚îÄ‚îÄ dev/
    ‚îÇ   ‚îî‚îÄ‚îÄ pipeline.yaml
    ‚îú‚îÄ‚îÄ staging/
    ‚îÇ   ‚îî‚îÄ‚îÄ pipeline.yaml
    ‚îî‚îÄ‚îÄ prod/
        ‚îî‚îÄ‚îÄ pipeline.yaml
```

**Ê≥®ÊÑè**Ôºö
- ‚úÖ ÊîØÊåÅÂú® `.tekton/` ‰∏ãÂàõÂª∫‰ªªÊÑèÂ±ÇÁ∫ßÁöÑÂ≠êÁõÆÂΩï
- ‚úÖ ÊâÄÊúâ `.yaml` Âíå `.yml` Êñá‰ª∂ÈÉΩ‰ºöË¢´Ëá™Âä®Ê£ÄÊµã
- ‚úÖ ÂèØ‰ª•ÊåâÂäüËÉΩ„ÄÅÁéØÂ¢ÉÊàñÂõ¢ÈòüÁªÑÁªáÊñá‰ª∂ÁªìÊûÑ
- ‚ùå ‰∏çÊîØÊåÅ `.tekton/` ÁõÆÂΩïÂ§ñÁöÑ Tekton ËµÑÊ∫ê

## üîß Â∏∏Áî® Tekton ËµÑÊ∫êÁ§∫‰æã

### Ëá™ÂÆö‰πâ Task Á§∫‰æã

```yaml
# .tekton/tasks/build-task.yaml
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: custom-build
spec:
  params:
    - name: project-type
      type: string
      default: "nodejs"
    - name: build-args
      type: string
      default: ""
  
  workspaces:
    - name: source
  
  steps:
    - name: detect-project-type
      image: alpine
      script: |
        #!/bin/sh
        cd $(workspaces.source.path)
        
        if [ -f "package.json" ]; then
          echo "nodejs" > /tmp/project-type
        elif [ -f "go.mod" ]; then
          echo "golang" > /tmp/project-type
        elif [ -f "pom.xml" ]; then
          echo "java" > /tmp/project-type
        elif [ -f "requirements.txt" ]; then
          echo "python" > /tmp/project-type
        else
          echo "unknown" > /tmp/project-type
        fi
    
    - name: build-project
      image: alpine
      script: |
        #!/bin/sh
        PROJECT_TYPE=$(cat /tmp/project-type)
        cd $(workspaces.source.path)
        
        echo "üî® Building $PROJECT_TYPE project..."
        
        case $PROJECT_TYPE in
          "nodejs")
            npm install
            npm run build $(params.build-args)
            ;;
          "golang")
            go build $(params.build-args) ./...
            ;;
          "java")
            mvn compile $(params.build-args)
            ;;
          "python")
            pip install -r requirements.txt
            python setup.py build $(params.build-args)
            ;;
          *)
            echo "‚ö†Ô∏è  Unknown project type, skipping build"
            ;;
        esac
        
        echo "‚úÖ Build completed!"
```

### Â§öÁéØÂ¢ÉÈÉ®ÁΩ≤ Pipeline

```yaml
# .tekton/pipeline-deploy.yaml
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: my-app-deploy
spec:
  params:
    - name: repository-url
    - name: commit-sha
    - name: repository-name
    - name: target-environment
      default: "development"
  
  workspaces:
    - name: source-code
    - name: docker-credentials
  
  tasks:
    - name: clone-source
      taskRef:
        name: git-clone
        kind: ClusterTask
      params:
        - name: url
          value: $(params.repository-url)
        - name: revision
          value: $(params.commit-sha)
      workspaces:
        - name: output
          workspace: source-code
    
    - name: build-and-push
      runAfter: ["clone-source"]
      taskSpec:
        workspaces:
          - name: source
          - name: dockerconfig
        params:
          - name: image-name
            default: "my-registry/$(params.repository-name):$(params.commit-sha)"
        steps:
          - name: build-and-push
            image: gcr.io/kaniko-project/executor:latest
            script: |
              #!/busybox/sh
              /kaniko/executor \
                --context $(workspaces.source.path) \
                --dockerfile $(workspaces.source.path)/Dockerfile \
                --destination $(params.image-name)
            env:
              - name: DOCKER_CONFIG
                value: $(workspaces.dockerconfig.path)
      workspaces:
        - name: source
          workspace: source-code
        - name: dockerconfig
          workspace: docker-credentials
    
    - name: deploy-to-environment
      runAfter: ["build-and-push"]
      taskSpec:
        params:
          - name: environment
          - name: image
          - name: app-name
        steps:
          - name: deploy
            image: bitnami/kubectl
            script: |
              #!/bin/bash
              echo "üöÄ Deploying to $(params.environment) environment..."
              
              # Ê†πÊçÆÁéØÂ¢ÉÈÄâÊã©ÂëΩÂêçÁ©∫Èó¥
              case $(params.environment) in
                "development")
                  NAMESPACE="dev-$(params.app-name)"
                  ;;
                "staging")
                  NAMESPACE="staging-$(params.app-name)"
                  ;;
                "production")
                  NAMESPACE="prod-$(params.app-name)"
                  ;;
                *)
                  echo "‚ùå Unknown environment: $(params.environment)"
                  exit 1
                  ;;
              esac
              
              # ÂàõÂª∫ÂëΩÂêçÁ©∫Èó¥ÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®Ôºâ
              kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
              
              # ÈÉ®ÁΩ≤Â∫îÁî®
              cat <<EOF | kubectl apply -f -
              apiVersion: apps/v1
              kind: Deployment
              metadata:
                name: $(params.app-name)
                namespace: $NAMESPACE
              spec:
                replicas: 1
                selector:
                  matchLabels:
                    app: $(params.app-name)
                template:
                  metadata:
                    labels:
                      app: $(params.app-name)
                  spec:
                    containers:
                    - name: app
                      image: $(params.image)
                      ports:
                      - containerPort: 8080
              EOF
              
              echo "‚úÖ Deployment completed!"
      params:
        - name: environment
          value: $(params.target-environment)
        - name: image
          value: "my-registry/$(params.repository-name):$(params.commit-sha)"
        - name: app-name
          value: $(params.repository-name)
```

## üîß È´òÁ∫ßÈÖçÁΩÆ

### Êù°‰ª∂ÊâßË°å

Ê†πÊçÆÂàÜÊîØÊàñÊñá‰ª∂ÂèòÊõ¥ÊâßË°å‰∏çÂêåÁöÑ‰ªªÂä°Ôºö

```yaml
# .tekton/conditional-pipeline.yaml
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: conditional-ci
spec:
  params:
    - name: repository-url
    - name: commit-sha
    - name: branch-name
  
  workspaces:
    - name: source-code
  
  tasks:
    - name: git-clone
      taskRef:
        name: git-clone
        kind: ClusterTask
      params:
        - name: url
          value: $(params.repository-url)
        - name: revision
          value: $(params.commit-sha)
      workspaces:
        - name: output
          workspace: source-code
    
    # Âè™Âú® main ÂàÜÊîØËøêË°åÈÉ®ÁΩ≤
    - name: deploy-to-production
      when:
        - input: "$(params.branch-name)"
          operator: in
          values: ["main", "master"]
      runAfter: ["git-clone"]
      taskSpec:
        steps:
          - name: deploy
            image: alpine
            script: |
              echo "üöÄ Deploying to production (branch: $(params.branch-name))..."
              # ÈÉ®ÁΩ≤ÈÄªËæë...
    
    # Âè™Âú®Èùû main ÂàÜÊîØËøêË°åÊµãËØï
    - name: run-dev-tests
      when:
        - input: "$(params.branch-name)"
          operator: notin
          values: ["main", "master"]
      runAfter: ["git-clone"]
      taskSpec:
        workspaces:
          - name: source
        steps:
          - name: test
            image: alpine
            script: |
              echo "üß™ Running development tests (branch: $(params.branch-name))..."
              # ÊµãËØïÈÄªËæë...
      workspaces:
        - name: source
          workspace: source-code
```

### Âπ∂Ë°å‰ªªÂä°ÊâßË°å

```yaml
# .tekton/parallel-pipeline.yaml
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: parallel-ci
spec:
  params:
    - name: repository-url
    - name: commit-sha
  
  workspaces:
    - name: source-code
  
  tasks:
    - name: git-clone
      taskRef:
        name: git-clone
        kind: ClusterTask
      params:
        - name: url
          value: $(params.repository-url)
        - name: revision
          value: $(params.commit-sha)
      workspaces:
        - name: output
          workspace: source-code
    
    # Âπ∂Ë°åÊâßË°åÁöÑ‰ªªÂä°
    - name: lint-code
      runAfter: ["git-clone"]
      taskSpec:
        workspaces:
          - name: source
        steps:
          - name: lint
            image: alpine
            script: |
              echo "üîç Running code linting..."
              # ‰ª£Á†ÅÊ£ÄÊü•ÈÄªËæë...
      workspaces:
        - name: source
          workspace: source-code
    
    - name: security-scan
      runAfter: ["git-clone"]
      taskSpec:
        workspaces:
          - name: source
        steps:
          - name: scan
            image: alpine
            script: |
              echo "üîí Running security scan..."
              # ÂÆâÂÖ®Êâ´ÊèèÈÄªËæë...
      workspaces:
        - name: source
          workspace: source-code
    
    - name: unit-tests
      runAfter: ["git-clone"]
      taskSpec:
        workspaces:
          - name: source
        steps:
          - name: test
            image: alpine
            script: |
              echo "üß™ Running unit tests..."
              # ÂçïÂÖÉÊµãËØïÈÄªËæë...
      workspaces:
        - name: source
          workspace: source-code
    
    # Á≠âÂæÖÊâÄÊúâÂπ∂Ë°å‰ªªÂä°ÂÆåÊàêÂêéÊâßË°å
    - name: build-application
      runAfter: ["lint-code", "security-scan", "unit-tests"]
      taskSpec:
        workspaces:
          - name: source
        steps:
          - name: build
            image: alpine
            script: |
              echo "üî® Building application..."
              # ÊûÑÂª∫ÈÄªËæë...
      workspaces:
        - name: source
          workspace: source-code
```

## üîç Ë∞ÉËØïÂíåÊïÖÈöúÊéíÈô§

### Êü•ÁúãÊâßË°åÊó•Âøó

```bash
# ÂàóÂá∫ÊÇ®ÁöÑÂëΩÂêçÁ©∫Èó¥‰∏≠ÁöÑÊâÄÊúâ PipelineRun
kubectl get pipelineruns -n reposentry-user-{namespace-hash}

# Êü•ÁúãÁâπÂÆö PipelineRun ÁöÑËØ¶ÁªÜ‰ø°ÊÅØ
kubectl describe pipelinerun {pipelinerun-name} -n reposentry-user-{namespace-hash}

# Êü•ÁúãÂÆûÊó∂Êó•Âøó
kubectl logs -f pipelinerun/{pipelinerun-name} -n reposentry-user-{namespace-hash}

# Êü•ÁúãÁâπÂÆö‰ªªÂä°ÁöÑÊó•Âøó
kubectl logs -f pipelinerun/{pipelinerun-name} -c step-{step-name} -n reposentry-user-{namespace-hash}
```

### Â∏∏ËßÅÈóÆÈ¢òËß£ÂÜ≥

#### 1. Pipeline Ê≤°ÊúâËá™Âä®Ëß¶Âèë

**ÂèØËÉΩÂéüÂõ†**Ôºö
- `.tekton/` ÁõÆÂΩï‰∏çÂ≠òÂú®Êàñ‰∏∫Á©∫
- YAML Êñá‰ª∂Ê†ºÂºèÈîôËØØ
- RepoSentry Ê≤°ÊúâÊ£ÄÊµãÂà∞ÂèòÊõ¥

**Ëß£ÂÜ≥ÊñπÊ≥ï**Ôºö
```bash
# Ê£ÄÊü• .tekton ÁõÆÂΩïÁªìÊûÑ
ls -la .tekton/

# È™åËØÅ YAML Êñá‰ª∂Ê†ºÂºè
yamllint .tekton/*.yaml

# ÊâãÂä®Ëß¶ÂèëÊ£ÄÊµãÔºàÂ¶ÇÊûúÊúâÊùÉÈôêÔºâ
curl -X POST http://reposentry-api/api/v1/repositories/{repo}/trigger
```

#### 2. ‰ªªÂä°ÊâßË°åÂ§±Ë¥•

**Â∏∏ËßÅÈîôËØØ**Ôºö
```yaml
# ÈîôËØØÁöÑÈïúÂÉèÂºïÁî®
steps:
  - name: build
    image: node:16-invalid  # ÈïúÂÉè‰∏çÂ≠òÂú®
    
# ÈîôËØØÁöÑÂ∑•‰ΩúÁõÆÂΩï
steps:
  - name: test
    workingDir: /nonexistent/path  # Ë∑ØÂæÑ‰∏çÂ≠òÂú®
    
# ÊùÉÈôê‰∏çË∂≥
steps:
  - name: deploy
    script: |
      kubectl apply -f deployment.yaml  # ÂèØËÉΩÊ≤°ÊúâÊùÉÈôê
```

**Ëß£ÂÜ≥ÊñπÊ≥ï**Ôºö
- ‰ΩøÁî®ÊúâÊïàÁöÑÈïúÂÉèÊ†áÁ≠æ
- Á°Æ‰øùÂ∑•‰ΩúÁõÆÂΩïÂ≠òÂú®
- Ê£ÄÊü•ÊâÄÈúÄÁöÑÊùÉÈôêÂíå RBAC ÈÖçÁΩÆ

#### 3. ËµÑÊ∫êÈÖçÈ¢ùË∂ÖÈôê

**ÈîôËØØ‰ø°ÊÅØ**Ôºö
```
Error: pods "my-task-pod" is forbidden: exceeded quota
```

**Ëß£ÂÜ≥ÊñπÊ≥ï**Ôºö
- ÂáèÂ∞ëÂπ∂Ë°å‰ªªÂä°Êï∞Èáè
- ‰ºòÂåñËµÑÊ∫êËØ∑Ê±ÇÂíåÈôêÂà∂
- ËÅîÁ≥ªÁÆ°ÁêÜÂëòË∞ÉÊï¥ÈÖçÈ¢ù

## üìö ÊúÄ‰Ω≥ÂÆûË∑µ

### 1. ËµÑÊ∫ê‰ºòÂåñ

```yaml
# ‰∏∫‰ªªÂä°ËÆæÁΩÆÂêàÈÄÇÁöÑËµÑÊ∫êÈôêÂà∂
taskSpec:
  stepTemplate:
    resources:
      requests:
        memory: "128Mi"
        cpu: "100m"
      limits:
        memory: "256Mi"
        cpu: "200m"
  steps:
    - name: build
      # ... ÂÖ∂‰ªñÈÖçÁΩÆ
```

### 2. ÈïúÂÉèÈÄâÊã©

```yaml
# ‰ΩøÁî®ËΩªÈáèÁ∫ßÈïúÂÉè
steps:
  - name: test
    image: alpine:3.18  # ËÄå‰∏çÊòØ ubuntu:latest
    
  # ‰ΩøÁî®ÁâπÂÆöÁâàÊú¨Ê†áÁ≠æ
  - name: build
    image: node:16.20.0-alpine  # ËÄå‰∏çÊòØ node:latest
```

### 3. ÂÆâÂÖ®ÂÆûË∑µ

```yaml
# ‰∏çË¶ÅÂú® YAML ‰∏≠Á°¨ÁºñÁ†ÅÊïèÊÑü‰ø°ÊÅØ
steps:
  - name: deploy
    env:
      - name: API_KEY
        valueFrom:
          secretKeyRef:
            name: api-credentials
            key: api-key
    script: |
      # ‰ΩøÁî®ÁéØÂ¢ÉÂèòÈáè
      curl -H "Authorization: Bearer $API_KEY" ...
```

### 4. ÈîôËØØÂ§ÑÁêÜ

```yaml
steps:
  - name: robust-task
    image: alpine
    script: |
      #!/bin/bash
      set -euo pipefail  # ‰∏•Ê†ºÈîôËØØÂ§ÑÁêÜ
      
      # Ê£ÄÊü•ÂøÖË¶ÅÁöÑÊñá‰ª∂
      if [ ! -f "required-file.txt" ]; then
        echo "‚ùå Required file not found"
        exit 1
      fi
      
      # ÊâßË°åÊìç‰ΩúÂπ∂Ê£ÄÊü•ÁªìÊûú
      if ! some-command; then
        echo "‚ùå Command failed"
        exit 1
      fi
      
      echo "‚úÖ Task completed successfully"
```

### 5. ÂèØÈáçÁî®ÊÄß

```yaml
# ‰ΩøÁî®ÂèÇÊï∞‰Ωø Pipeline Êõ¥ÁÅµÊ¥ª
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: reusable-ci
spec:
  params:
    - name: repository-url
    - name: commit-sha
    - name: build-image
      default: "node:16"
    - name: test-command
      default: "npm test"
    - name: build-command
      default: "npm run build"
  
  tasks:
    - name: flexible-build
      taskSpec:
        params:
          - name: build-image
          - name: test-cmd
          - name: build-cmd
        steps:
          - name: test
            image: $(params.build-image)
            script: $(params.test-cmd)
          - name: build
            image: $(params.build-image)
            script: $(params.build-cmd)
      params:
        - name: build-image
          value: $(params.build-image)
        - name: test-cmd
          value: $(params.test-command)
        - name: build-cmd
          value: $(params.build-command)
```

## üîó Áõ∏ÂÖ≥ËµÑÊ∫ê

- [Tekton Pipelines ÂÆòÊñπÊñáÊ°£](https://tekton.dev/docs/pipelines/)
- [Tekton Tasks Catalog](https://hub.tekton.dev/)
- [Kubernetes ËµÑÊ∫êÁÆ°ÁêÜ](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/)
- [YAML ËØ≠Ê≥ïÊåáÂçó](https://yaml.org/spec/)

## üí¨ Ëé∑ÂèñÂ∏ÆÂä©

Â¶ÇÊûúÊÇ®Âú®‰ΩøÁî®ËøáÁ®ã‰∏≠ÈÅáÂà∞ÈóÆÈ¢òÔºö

1. **Êü•ÁúãÊó•Âøó**ÔºöÈ¶ñÂÖàÊ£ÄÊü• PipelineRun ÁöÑÊâßË°åÊó•Âøó
2. **È™åËØÅ YAML**ÔºöÁ°Æ‰øùÊÇ®ÁöÑ Tekton ËµÑÊ∫êÊ†ºÂºèÊ≠£Á°Æ
3. **Ê£ÄÊü•ÊùÉÈôê**ÔºöÁ°ÆËÆ§ÊÇ®ÁöÑ Pipeline ÊúâË∂≥Â§üÁöÑÊùÉÈôêÊâßË°åÊâÄÈúÄÊìç‰Ωú
4. **ÂèÇËÄÉÁ§∫‰æã**ÔºöÊü•ÁúãÊú¨ÊåáÂçó‰∏≠ÁöÑÁ§∫‰æãÂíåÊúÄ‰Ω≥ÂÆûË∑µ
5. **ËÅîÁ≥ªÊîØÊåÅ**ÔºöÂ¶ÇÊûúÈóÆÈ¢ò‰ªçÁÑ∂Â≠òÂú®ÔºåËØ∑ËÅîÁ≥ªÊÇ®ÁöÑÂπ≥Âè∞ÁÆ°ÁêÜÂëò

---

**Ê≥®ÊÑè**ÔºöRepoSentry ÁöÑ Tekton ÈõÜÊàêÂäüËÉΩÂÆåÂÖ®ÈÄèÊòéÔºåÊÇ®Êó†ÈúÄÈÖçÁΩÆ‰ªª‰Ωï Webhook ÊàñËøõË°åÈ¢ùÂ§ñËÆæÁΩÆ„ÄÇÂè™ÈúÄÂú®‰ªìÂ∫ì‰∏≠Ê∑ªÂä† `.tekton/` ÁõÆÂΩïÂíåÁõ∏ÂÖ≥ YAML Êñá‰ª∂ÔºåÁ≥ªÁªü‰ºöËá™Âä®Ê£ÄÊµãÂπ∂ÊâßË°åÊÇ®ÁöÑ Pipeline„ÄÇ

